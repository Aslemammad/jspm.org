<html><head><meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400">
<link rel="stylesheet" href="/style.css">
<script defer="" src="/script.js"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-40327700-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-40327700-2');
</script>
<title>Getting Started - jspm.org</title></head><body>
<div class="topbar">
    <a style="display: block" href="/">
      <div class="logobox" href="/"></div>
      <h1 class="logo">jspm</h1>
    </a>
    <ul class="toplinks">
      <li><a href="/guide/getting-started">Guide</a></li>
      <!-- <li><a href="/api">API</a></li> -->
      <!-- <li><a href="/sandbox">Sandbox</a></li> -->
      <li><a href="/about/features">About</a></li>
      <li class="github"><a target="_blank" href="https://github.com/jspm/jspm2-cli" rel="noopener"></a></li>
    </ul>
  </div>
<div class="sidebar">
  <div class="toc">
    <ul class="sections"><li class="about"><a href="/about/features">About</a><ul class="section-about"><li class="features"><a href="/about/features">Features</a></li><li class="background"><a href="/about/background">Background</a></li><li class="architecture"><a href="/about/architecture">Architecture</a></li></ul></li><li class="guide active"><a href="/guide/getting-started">Guide</a><ul class="section-guide"><li class="getting-started active"><a href="/guide/getting-started">Getting Started</a><ul class="subsection"><li><a href="#install-jspm-20-beta">Install jspm 2.0 beta</a></li><li><a href="#create-a-project">Create a Project</a></li><li><a href="#install-dependencies">Install Dependencies</a></li><li><a href="#executing-es-modules">Executing ES Modules</a></li><li><a href="#execution-in-the-browser">Execution in the Browser</a></li><li><a href="#building-for-the-browser">Building for the Browser</a></li><li><a href="#building-for-legacy-browsers">Building for Legacy Browsers</a></li><li><a href="#partial-builds">Partial Builds</a></li><li><a href="#running-a-custom-build">Running a Custom Build</a></li><li><a href="#cdn-package-maps">CDN Package Maps</a></li><li><a href="#further-features-not-yet-covered-in-this-tutorial-or-docs">Further Features not yet covered in this tutorial or docs</a></li></ul></li><li class="workflows"><a href="/guide/workflows">Workflows</a></li><li class="integrations"><a href="/guide/integrations">Tool Integrations</a></li></ul></li>
      <!-- Table of contents links will be added here -->
      <li><a>Resources</a>
      <ul class="subsection">
        <li><a target="_blank" href="https://github.com/jspm/jspm2-cli" rel="noopener">GitHub</a></li>
        <li><a target="_blank" href="/docs" rel="noopener">Contributing</a></li>
        <li><a target="_blank" href="https://gitter.im/jspm/jspm" rel="noopener">Gitter</a></li>
        <li><a target="_blank" href="/docs" rel="noopener">jspm 0.16</a></li>
        <li><a target="_blank" href="/0.17-beta-guide" rel="noopener">jspm 0.17</a></li>
      </ul>
      </li>
    </ul>
  </div>
  <div class="footer">
    <p>Logo design by <a target="_blank" href="https://dribbble.com/luukdv" rel="noopener">Luuk de Vlieger</a></p>
  </div>
</div>
<div class="content"><h1>Getting Started</h1>
<a name="install-jspm-20-beta" class="anchor"></a><h2>Install jspm 2.0 beta</h2>
<p>Make sure your GitHub SSH keys are configured correctly then:</p>
<pre><code>npm install -g git+ssh://git@github.com/jspm/jspm2-cli#2.<span class="number">0</span></code></pre><p>Also make sure to run NodeJS 10.x or greater.</p>
<p>To see the full list of options available run <code>jspm help</code>. This guide only touches on the basics.</p>
<a name="create-a-project" class="anchor"></a><h2>Create a Project</h2>
<pre><code>mkdir jspm-test
cd jspm-test</code></pre><a name="install-dependencies" class="anchor"></a><h2>Install Dependencies</h2>
<p>As expected:</p>
<pre><code>jspm install lodash @babel/core</code></pre><p>This will populate the dependencies in <code>package.json</code> and also generate a <code>jspm.json</code> lockfile. <em>Do not delete either of these, as both are used by the resolver.</em></p>
<blockquote>
<p>A lot of effort has been made to make installs run really fast. There's also support for <code>install --offline</code> and <code>install --prefer-offline</code> as expected these days.</p>
</blockquote>
<a name="executing-es-modules" class="anchor"></a><h2>Executing ES Modules</h2>
<p>test.js</p>
<pre><code class="language-js"><span class="keyword">import</span> clone <span class="keyword">from</span> <span class="string">'lodash/clone.js'</span>;

console.log(clone({ a: <span class="string">'b'</span> }));

import(<span class="string">'@babel/core'</span>).then(({ default: babel }) =&gt; {
  console.log(babel.transform(<span class="string">'test'</span>).code);
});</code></pre>
<pre><code>jspm test.js</code></pre><p>When executing jspm is using the NodeJS <code>--experimental-modules</code> feature directly, configuring the jspm resolver through the NodeJS <code>--loader</code> hooks so this is using full native ES module support in Node.js.</p>
<blockquote>
<p>This will support Node 8.x and up, although dynamic import is only supported in Node 10.x and up</p>
</blockquote>
<p>To see how jspm is executing Node.js running <code>jspm bin</code> will output the Node.js execution command:</p>
<pre><code>jspm bin</code></pre><p>This command can be used directly to execute Node.js with the jspm resolution - all jspm needs to work in any execution environment, builder or other tool is a resolver hook to integrate the jspm_packages resolution.</p>
<a name="execution-in-the-browser" class="anchor"></a><h2>Execution in the Browser</h2>
<p>To run a local server lets install <code>http-server</code> from npm with jspm:</p>
<pre><code>jspm install http-server --dev
jspm_packages/.bin/http-server</code></pre><blockquote>
<p>If running in Windows, use <code>jspm_packages/.bin/http-server.cmd</code> in the above.</p>
</blockquote>
<p>jspm supports many npm packages using the same jspm_packages resolution and ES module conversion that we run in the browser.<br>It's all running through --experimental-modules, ES modules and the jspm resolver.</p>
<p>We can then set this up with a package.json script just like with npm:</p>
<pre><code class="language-json">{
  <span class="string">"scripts"</span>: {
    <span class="string">"serve"</span>: <span class="string">"http-server"</span>
  }
}</code></pre>
<p>which will then support:</p>
<pre><code>jspm run serve</code></pre><p>Now to execute our original example in the browser, we can create a import map:</p>
<pre><code>jspm map ./test.js -o importmap.json</code></pre><p>This will create just the maps necessary to load <code>lodash/clone</code>.</p>
<blockquote>
<p><code>jspm map</code> with no arguments will create the full import map for everything that is installed. By default import maps are created based on browser development environment. Passing <code>--production</code> will resolve based on the production conditional.</p>
</blockquote>
<p>To support import maps in the browser, we need to use the es-module-shims project:</p>
<pre><code>jspm install es-module-shims --dev</code></pre><p>To find out where <code>es-module-shims</code> is located we can use <code>jspm resolve</code>:</p>
<pre><code>jspm resolve --relative es-module-shims
jspm_packages/npm/es-module-shims@<span class="number">0</span>.<span class="number">2</span>.<span class="number">3</span>/dist/es-module-shims.js</code></pre><p>We can then reference this path to load that file directly in an HTML file:</p>
<p>test.html</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;script type=<span class="string">"module"</span> src=<span class="string">"jspm_packages/npm/es-module-shims@<span class="number">0</span>.<span class="number">2</span>.<span class="number">3</span>/dist/es-module-shims.js"</span>&gt;&lt;/script&gt;
&lt;script type=<span class="string">"importmap-shim"</span> src=<span class="string">"importmap.json"</span>&gt;&lt;/script&gt;
&lt;script type=<span class="string">"module-shim"</span> src=<span class="string">"test.js"</span>&gt;&lt;/script&gt;</code></pre>
<p>Running <code>jspm run serve</code> we can load this page to see the expected results in the console.</p>
<p><strong>We are loading 100s of ES modules converted from Node.js semantics to work natively in the browser with only a import map.</strong></p>
<blockquote>
<p><a href="https://github.com/guybedford/es-module-shims">ES Module Shims</a> supports package name maps only for browsers that already support ES modules. Its module lexing is fast enough that it is actually suitable for prodution workflows. When import maps are natively supported in browsers, this project will no longer be necessary.</p>
</blockquote>
<a name="building-for-the-browser" class="anchor"></a><h2>Building for the Browser</h2>
<p>Since Lodash is not optimized for browser delivery we still want to do a modular build for production.</p>
<p>To build with Rollup, we can use the <code>jspm build</code> command:</p>
<pre><code>jspm build test.js --inline-deps</code></pre><blockquote>
<p>By default <code>jspm build</code> will build for the browser development environment. Use <code>--node</code> to build for Node.js resolution (not applying the package.json "browser" field, or similarly <code>--production</code> for the production environment).</p>
</blockquote>
<p>By default, jspm will automatically treat any <code><span class="string">"dependencies"</span></code> of the project as externals, so <code>--inline-deps</code> will ensure lodash and babel are bundled into our build files.</p>
<p>This will output a file at <code>dist/test.js</code> containing our build.</p>
<p>We can now update the test page to reference this build file:</p>
<p>test-build.html</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;script type=<span class="string">"module"</span> src=<span class="string">"jspm_packages/npm/es-module-shims@<span class="number">0</span>.<span class="number">2</span>.<span class="number">3</span>/dist/es-module-shims.js"</span>&gt;&lt;/script&gt;
&lt;script type=<span class="string">"module-shim"</span> src=<span class="string">"dist/test.js"</span>&gt;&lt;/script&gt;</code></pre>
<p>Loading the page in the browser with <code>jspm run serve</code> notice how we are just loading three files now:</p>
<ul>
<li>The initial chunk that loads lodash/clone</li>
<li>The dynamic chunk that loads Babel</li>
<li>A shared chunk containing dependencies shared between both of the above</li>
</ul>
<p>We thus have an optimal build for distributing to users for a fast load.</p>
<blockquote>
<p>Use <code>--watch</code> for a watched build while developing.</p>
</blockquote>
<a name="building-for-legacy-browsers" class="anchor"></a><h2>Building for Legacy Browsers</h2>
<p>To support this same code in legacy browsers, we build into the SystemJS module format:</p>
<pre><code>jspm build test.js -f system -o dist-system --inline-deps</code></pre><p>Install SystemJS, and verify its path:</p>
<pre><code>jspm install systemjs --dev</code></pre><p>We can then update <code>test-build.html</code> to work in both legacy and modern browsers with the following:</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;script type=<span class="string">"module"</span> src=<span class="string">"jspm_packages/npm/es-module-shims@<span class="number">0</span>.<span class="number">2</span>.<span class="number">3</span>/dist/es-module-shims.js"</span>&gt;&lt;/script&gt;
&lt;script type=<span class="string">"module-shim"</span> src=<span class="string">"dist/test.js"</span>&gt;&lt;/script&gt;

&lt;script nomodule src=<span class="string">"jspm_packages/npm/systemjs@<span class="number">3</span>.<span class="number">1</span>.<span class="number">0</span>/dist/s.min.js"</span>&gt;&lt;/script&gt;
&lt;script nomodule&gt;System.import(<span class="string">'./dist-system/test.js'</span>)&lt;/script&gt;</code></pre>
<p>Since both es-module-shims and SystemJS support import maps, we can provide full modular workflows using these techniques back to IE11!</p>
<p>For IE11 support, <a href="https://github.com/systemjs/systemjs#polyfills-for-older-browsers">see the polyfills section of the SystemJS readme</a>,
note the appropriate Babel plugins for browser support would need to be applied as well, see the custom builds section shortly.</p>
<a name="partial-builds" class="anchor"></a><h2>Partial Builds</h2>
<p>A key concept that is enabled by the fact that we are building ES modules is that unlike previous bundling approaches, there is no cost to iterative builds.</p>
<p>That is, we can build parts of an application together, then bundle those parts into other importers again. Building can mix in this way any number of times.</p>
<p>For example, say <code>test.js</code> was split into two separate files:</p>
<p>test.js</p>
<pre><code class="language-js"><span class="keyword">import</span> clone <span class="keyword">from</span> <span class="string">'lodash/clone.js'</span>;
<span class="keyword">import</span> <span class="string">'./test-babel.js'</span>;

console.log(clone({ a: <span class="string">'b'</span> }));</code></pre>
<p>test-babel.js</p>
<pre><code class="language-js">import(<span class="string">'@babel/core'</span>).then(({ default: babel }) =&gt; {
  console.log(babel.transform(<span class="string">'test'</span>).code);
});</code></pre>
<p>Now lets leave out the <code>--inline-deps</code> option:</p>
<pre><code>jspm build test.js</code></pre><p>Even though we've now done a build, we can still generate a import map for the built application, and only the external packages used will be included:</p>
<pre><code>jspm map ./dist/test.js -o importmap.json</code></pre><p>Alternatively, if lodash/clone.js was small enough it might make sense to inline, leaving only the Babel dependency external:</p>
<pre><code>jspm build test.js --inline-deps --external lodash/clone.js</code></pre><p>It is this kind of balance that needs to be worked out in configuring the external boundary for the local build.</p>
<p>Ideally, this kind of partial build should be done for all packages before publishing.</p>
<blockquote>
<p>While Babel and Lodash are not optimized themselves, if all packages performed these sorts of optimizations on publish, then we would be getting 10s of requests in the browser not 100s, and these workflows may even become suitable in production.</p>
</blockquote>
<a name="running-a-custom-build" class="anchor"></a><h2>Running a Custom Build</h2>
<p>The <code>jspm build</code> command only offers the very basic JS semantics for builds. For custom build configurations, you'll usually want<br>to "eject" out of this workflow and just use Rollup directly.</p>
<p>Let's do that now:</p>
<pre><code>jspm install rollup rollup-plugin-jspm=github:jspm/rollup-plugin-jspm --dev</code></pre><p>Create the following <code>rollup.config.js</code>:</p>
<pre><code class="language-js"><span class="keyword">import</span> jspmPlugin <span class="keyword">from</span> <span class="string">'rollup-plugin-jspm'</span>;

<span class="keyword">export</span> default {
  input: [<span class="string">'test.js'</span>],
  output: {
    dir: <span class="string">'dist'</span>,
    format: <span class="string">'esm'</span>
  },
  plugins: [jspmPlugin({
    env: {
      production: <span class="keyword">true</span>
    }
  })]
};</code></pre>
<p>We can then run <code>jspm_packages/.bin/rollup -c</code> or again set this up as a package.json "scripts" entry.</p>
<blockquote>
<p>To build for Node.js set the <code>env.node: true</code> build flag.</p>
</blockquote>
<p>In this way we can now add any custom configuration support for Babel / TypeScript etc.</p>
<p>Because the jspm plugin is just a <code>resolve</code> function in Rollup, it is very simple to make plugins for Webpack, Parcel and other tools. Help expanding this is very welcome!</p>
<a name="cdn-package-maps" class="anchor"></a><h2>CDN Package Maps</h2>
<p>Instead of building a import map against the local jspm_packages packages folder, the jspm CDN can be used instead as the import map target.</p>
<p>To do this in the original import map example we just add the <code>--cdn</code> flag:</p>
<pre><code>jspm map ./test.js -o importmap.json --cdn</code></pre><p>Loading the previous <code>test.html</code> in the browser, in the network tab all requests are now made against <code>https://mapdev.jspm.io</code>.</p>
<p>Because the structure of jspm_packages is universal, we can just change the reference in this way.</p>
<p>To use a custom jspm_packages path such as your own CDN library server use <code>--jspmPackages https://mysite.com</code> rather.</p>
<a name="further-features-not-yet-covered-in-this-tutorial-or-docs" class="anchor"></a><h2>Further Features not yet covered in this tutorial or docs</h2>
<p>TODO: flesh these out!</p>
<p>(see also <code>jspm help</code>)</p>
<ul>
<li><code>jspm clean</code> to clear jspm_packages</li>
<li><code>jspm link</code> for linking local projects</li>
<li><code>jspm checkout</code> for modifying installed packages</li>
<li>Custom registries</li>
<li>Global configuration API</li>
<li>Authentication management</li>
<li><code>jspm resolve</code></li>
<li>Map configuration and conditional resolution</li>
<li><code>jspm publish</code> for publishing</li>
</ul>
<div class="nextprev"><div class="next"><a href="/guide/workflows">Workflows&nbsp;⯈</a></div></div></div>


</body></html>