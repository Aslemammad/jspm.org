<html><head><meta property="og:title" content="jspm.org - Tool Integrations"><meta property="og:image" content="https://jspm.org/jspm.png"><meta property="og:url" content="https://jspm.org/docs/integrations"><meta name="twitter:card" content="summary_large_image"><meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style.css">
<script defer="" src="/script.js"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-40327700-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-40327700-2');
</script>
<title>Tool Integrations - jspm.org</title></head><body class="section-docs page-integrations">
<div class="topbar">
  <a style="display: block" href="/">
    <div class="logobox" href="/"></div>
    <h1 class="logo">jspm</h1>
  </a>
  <ul class="toplinks">
    <li><a href="/about/introduction">About</a></li>
    <li><a href="/docs/guide">Guide</a></li>
    <li><a href="/sandbox">Sandbox</a></li>
    <li class="github"><a target="_blank" href="https://github.com/jspm/jspm-cli" rel="noopener"></a></li>
  </ul>
  <div class="mobile-menu"></div>
</div>
<div class="sidebar">
  <div class="toc">
    <ul class="sections"><li class="about"><a href="/about/introduction">About</a><ul class="section-about"><li class="introduction"><a href="/about/introduction">Introduction</a></li></ul></li><li class="docs active"><a href="/docs/guide">Docs</a><ul class="section-docs"><li class="guide"><a href="/docs/guide">Guide</a></li><li class="integrations active"><a href="/docs/integrations">Tool Integrations</a><ul class="subsection"><li><a href="#resolver-hook">Resolver Hook</a></li><li><a href="#angular">Angular</a></li><li><a href="#babel">Babel</a></li><li><a href="#electron">Electron</a></li><li><a href="#jest">Jest</a></li><li><a href="#mocha">Mocha</a></li><li><a href="#npm">npm</a></li><li><a href="#parcel">Parcel</a></li><li><a href="#react">React</a></li><li><a href="#react-native">React Native</a></li><li><a href="#rollup">Rollup</a></li><li><a href="#svelte">Svelte</a></li><li><a href="#terser">Terser</a></li><li><a href="#typescript">TypeScript</a></li><li><a href="#vuejs">Vue.js</a></li><li><a href="#webpack">Webpack</a></li><li><a href="#one-weird-trick-to-support-jspm-in-tools">One Weird Trick to Support jspm in Tools</a></li></ul></li></ul></li>
      <!-- Table of contents links will be added here -->
      <li><a>Resources</a>
      <ul class="subsection">
        <li><a href="/sandbox">Sandbox</a></li>
        <li><a target="_blank" href="https://github.com/jspm/jspm2-cli" rel="noopener">GitHub</a></li>
        <li><a target="_blank" href="https://github.com/jspm/project/blob/master/CONTRIBUTING.md" rel="noopener">Contributing</a></li>
        <li><a target="_blank" href="https://gitter.im/jspm/jspm" rel="noopener">Gitter</a></li>
        <li><a target="_blank" href="/docs/0.16/index.html" rel="noopener">jspm 0.16</a></li>
        <li><a target="_blank" href="/docs/0.17-beta/index.html" rel="noopener">jspm 0.17</a></li>
      </ul>
      </li>
    </ul>
  </div>
  <div class="footer"><p>
    Logo design by <a target="_blank" href="https://dribbble.com/luukdv" rel="noopener">Luuk de Vlieger</a>
  </p></div>
</div>
<div class="content"><h1>Tool Integrations</h1>
<p>This section, still a work-in-progress, provides sample workflows and links to plugins for jspm support in other tools.</p>
<p><a href="https://github.com/jspm/jspm.org/blob/master/docs/integrations.md" target="_blank" rel="noopener">Provide a PR to this page</a> to list new tooling and framework integrations here, or to improve or revise an existing one. If you write a plugin for a tooling integration, you can request access to have it transferred into the <a href="https://github.com/jspm" target="_blank" rel="noopener">jspm organization on GitHub</a>. If you'd like to work on one of these workflows, but don't know where to start, see the <a href="https://github.com/jspm/project/blob/master/CONTRIBUTING.md" target="_blank" rel="noopener">contributing guide</a>.</p>
<a name="resolver-hook" class="anchor"></a><h2>Resolver Hook</h2>
<p>Integrating a tool that performs module resolution, such as a build tool, requires providing the jspm resolver as a hook or plugin to that tool.</p>
<p>The jspm resolver is maintained as a library at <a href="https://github.com/jspm/jspm-resolve" target="_blank" rel="noopener">https://github.com/jspm/jspm-resolve</a>, where the full API details are found at the GitHub page.</p>
<a name="angular" class="anchor"></a><h2>Angular</h2>
<p><em>Integration workflows pending.</em></p>
<a name="babel" class="anchor"></a><h2>Babel</h2>
<p>To run a jspm build with Babel see the <a href="#Rollup">jspm Rollup build example</a> which uses Babel.</p>
<p>To run Babel as a precompilation (recommended), use the workflow below.</p>
<details>
<summary>Babel Precompilation Workflow</summary>

<blockquote>
<p><code>jspm install</code> support for Babel CLI currently doesn't work as there is no way to use dynamic <code><span class="keyword">import</span>()</code> to load the Babel plugins which is required if they are installed with jspm. If and when Babel supports asynchronous / promise-based plugin configuration, then we'll be able to support this. See the tracking issue at <a href="https://github.com/babel/babel/issues/9888" target="_blank" rel="noopener">https://github.com/babel/babel/issues/9888</a>.</p>
</blockquote>
<p>First <a href="#npm">separate the jspm and npm dependencies</a> in the <code>package.json</code>:</p>
<pre><code class="language-json">{
  <span class="string">"jspm"</span>: {}
}</code></pre>
<p>Install Babel and any plugins:</p>
<pre><code>npm install @babel/core @babel/cli @babel/preset-env --dev</code></pre><p>Create a <code>babel.config.js</code>:</p>
<pre><code>module.exports = {
  sourceMap: <span class="keyword">true</span>,
  presets: [<span class="string">"@babel/preset-env"</span>]
};</code></pre><p>And set up the <code>package.json</code> <code><span class="string">"scripts"</span></code> entry:</p>
<pre><code class="language-js">{
  <span class="string">"scripts"</span>: {
    <span class="string">"compile"</span>: <span class="string">"babel src -d lib"</span>,
    <span class="string">"compile-watch"</span>: <span class="string">"babel src -d lib --watch"</span>
  }
}</code></pre>
<p><code>jspm run compile</code> (or <code>compile-watch</code>) will now compile all the individual <code>src</code> files to the <code>lib</code> directory, where they can then be optimized further <a href="/docs/guide#optimized-browser-builds">as in the main guide workflows</a>.</p>
</details>

<a name="electron" class="anchor"></a><h2>Electron</h2>
<p><em>Electron workflows pending.</em></p>
<p>Support for Electron package resolution is provided via the <code>--electron</code> flag in all commands that take environment conditions such as <code>jspm build</code> and <code>jspm map</code>.</p>
<a name="jest" class="anchor"></a><h2>Jest</h2>
<p><em>Jest plugin pending.</em></p>
<a name="mocha" class="anchor"></a><h2>Mocha</h2>
<p>Mocha tests can be run with a custom jspm test harness. A boilerplate approach for this is provided below.</p>
<details>
<summary>Mocha Test Runner</summary>

<pre><code>jspm install mocha</code></pre><p>Create the following runner in a <code>test/test.js</code> file:</p>
<pre><code class="language-js"><span class="keyword">import</span> Mocha <span class="keyword">from</span> <span class="string">'mocha'</span>;
<span class="keyword">import</span> { dirname } <span class="keyword">from</span> <span class="string">'path'</span>;
<span class="keyword">import</span> { fileURLToPath } <span class="keyword">from</span> <span class="string">'url'</span>;
<span class="keyword">import</span> { promises as fs } <span class="keyword">from</span> <span class="string">'fs'</span>;

(async () =&gt; {
  <span class="keyword">const</span> __dirname = dirname(fileURLToPath(<span class="keyword">import</span>.meta.url));
  <span class="keyword">const</span> tests = (<span class="keyword">await</span> fs.readdir(__dirname)).filter(name =&gt; name.endsWith(<span class="string">'.js'</span>));
  <span class="keyword">const</span> mocha = <span class="keyword">new</span> Mocha({
<span class="comment">    // Set Mocha options here</span>
  });

  <span class="keyword">for</span> (<span class="keyword">const</span> test of tests) {
    mocha.suite.emit(<span class="string">'pre-require'</span>, global, test, mocha);
    <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'./'</span> + test);
  }

  mocha.run();
})()
.catch(e =&gt; {
  console.error(e);
});</code></pre>
<p>This can be executed with <code>jspm test/test.js</code>, or in the <code>package.json</code>:</p>
<pre><code class="language-json">{
  <span class="string">"scripts"</span>: {
    <span class="string">"test"</span>: <span class="string">"jspm test/test.js"</span>
  }
}</code></pre>
<p>The above will run all <code>test/*.js</code> test files through Mocha.</p>
</details>

<p>Support for the Mocha CLI still needs to be provided, likely with some PR work to Mocha itself. This is because Mocha uses <code>require()</code> to load tests, which doesn't support ES modules in jspm. If it had a mode to use the ES dynamic <code><span class="keyword">import</span>()</code> then we could support it fully natively.</p>
<a name="npm" class="anchor"></a><h2>npm</h2>
<p>If using npm and jspm in the same project, add a <code><span class="string">"jspm"</span></code> property to your <code>package.json</code> to separate jspm dependencies from npm dependencies:</p>
<pre><code class="language-json">{
  <span class="string">"jspm"</span>: {}
}</code></pre>
<ul>
<li><code>jspm install x</code>: Will install into <code>jspm.dependencies</code> in the <code>package.json</code> file.</li>
<li><code>npm install x</code>: Will install into <code>dependencies</code> in the <code>package.json</code> file.</li>
</ul>
<p>Package.json scripts via <code>jspm run</code> will support bin files in both <code>jspm_packages/.bin</code> falling back to <code>node_modules/.bin</code>.</p>
<p>Imports in Node.js throgh <code>jspm</code> will also fall back to the <code>node_modules</code> resolution before the module not found error.</p>
<a name="parcel" class="anchor"></a><h2>Parcel</h2>
<p><em>Parcel plugin pending.</em></p>
<a name="react" class="anchor"></a><h2>React</h2>
<p>React will install with jspm and build for the browser, Node.js (<code>--node</code>), development or production (<code>--production</code>) through <code>jspm build</code>.</p>
<p>To support JSX compilation, use a <a href="#Babel">Babel</a> or <a href="#TypeScript">TypeScript</a> workflow, with the <a href="https://babeljs.io/docs/en/babel-preset-react" target="_blank" rel="noopener">Babel JSX Preset</a>, or setting the <code>jsx</code> TypeScript compilation option.</p>
<a name="react-native" class="anchor"></a><h2>React Native</h2>
<p><em>React Native workflows pending.</em></p>
<p>jspm does provide support for React Native resolution through the <code>--react-native</code> flag. All commands that support <code>--browser</code> and <code>--node</code> also support <code>--react-native</code> to resolve the React Native package main in dependencies.</p>
<a name="rollup" class="anchor"></a><h2>Rollup</h2>
<p>The Rollup plugin for jspm is <a href="https://github.com/jspm/rollup-plugin-jspm" target="_blank" rel="noopener">rollup-plugin-jspm</a>.</p>
<p><code>jspm build</code> provides a simple wrapper around this plugin, but for more advanced build workflows you'll typically want to use this plugin directly. A sample dual-build workflow is provided below.</p>
<details>
<summary>Babel Build with rollup-plugin-jspm</summary>

<p>Install Rollup, The <a href="https://github.com/jspm/rollup-plugin-jspm" target="_blank" rel="noopener">Rollup jspm plugin</a>, and <a href="https://github.com/rollup/rollup-plugin-babel" target="_blank" rel="noopener">Rollup Plugin Babel</a>:</p>
<pre><code>jspm install rollup rollup-plugin-jspm rollup-plugin-babel@latest --dev</code></pre><p>Create the following <code>rollup.config.js</code> file:</p>
<pre><code class="language-js"><span class="keyword">import</span> jspm <span class="keyword">from</span> <span class="string">'rollup-plugin-jspm'</span>;
<span class="keyword">import</span> babel <span class="keyword">from</span> <span class="string">'rollup-plugin-babel'</span>;

<span class="keyword">export</span> default {
<span class="comment">  // Leading <span class="string">"./"</span> still important here</span>
  input: [<span class="string">'./test.js'</span>],
  output: {
    dir: <span class="string">'dist'</span>,
    format: <span class="string">'esm'</span>
  },
  plugins: [jspm({
    env: {
      node: <span class="keyword">true</span>,
      production: <span class="keyword">true</span>
    }
  }), babel({
    exclude: <span class="string">'jspm_packages/**'</span>
  })]
};</code></pre>
<p>Run <code>jspm_packages/.bin/rollup -c</code> or setup the <code>package.json</code> <code><span class="string">"scripts"</span></code> entry:</p>
<pre><code class="language-json">{
  <span class="string">"scripts"</span>: {
    <span class="string">"build"</span>: <span class="string">"rollup -c"</span>
  }
}</code></pre>
<blockquote>
<p>In this example we're building for the Node.js production environment (handling the correct resolutions, <code>process.env.NODE_ENV</code> etc). By default, jspm will build for the browser development environment.</p>
</blockquote>
<p>Further plugins and build customizations can then be added to the above.</p>
</details>

<a name="svelte" class="anchor"></a><h2>Svelte</h2>
<p><em>Integration workflows pending.</em></p>
<a name="terser" class="anchor"></a><h2>Terser</h2>
<p>Terser minification is provided by <code>jspm build</code> when passing the <code>--minify</code> option.</p>
<p>To use <a href="https://github.com/terser-js/terser" target="_blank" rel="noopener">Terser</a> directly, use the <a href="https://github.com/TrySound/rollup-plugin-terser" target="_blank" rel="noopener">Terser Rollup plugin</a> in a custom <a href="#Rollup">jspm Rollup build</a>.</p>
<a name="typescript" class="anchor"></a><h2>TypeScript</h2>
<p>TypeScript support can be included through a Rollup, Parcel or Webpack integration, but if you'd like to avoid a monolithic build, running <code>typescript</code> directly as a separate step before jspm, can provide a nice incremental workflow where only changed files are build on each rerun.</p>
<p>TypeScript itself needs to be installed with <code>npm install -g typescript</code> (jspm support tracking in <a href="https://github.com/jspm/jspm2-cli/issues/61" target="_blank" rel="noopener">https://github.com/jspm/jspm2-cli/issues/61</a>).</p>
<p>See the workflow below for more details.</p>
<details>
<summary>Direct Incremental TypeScript Compilation</summary>

<p>Since we are installing TypeScript with npm, we should <a href="#npm">separate the jspm dependencies from npm dependencies</a> in the <code>package.json</code>:</p>
<pre><code class="language-json">{
  <span class="string">"jspm"</span>: {}
}</code></pre>
<p>Install TypeScript:</p>
<pre><code>npm install typescript</code></pre><p>Installing any dependencies does require installing both the TypeScript types with npm and the jspm version separately:</p>
<pre><code>jspm install react
npm install @types/react</code></pre><blockquote>
<p>You can skip installing the type dependencies, but this will provide compilation errors, even though the compilation will still complete successfully.</p>
</blockquote>
<p>Create the <code>tsconfig.json</code> file:</p>
<pre><code class="language-json">{
  <span class="string">"compilerOptions"</span>: {
    <span class="string">"allowSyntheticDefaultImports"</span>: <span class="keyword">true</span>,
    <span class="string">"module"</span>: <span class="string">"ESNext"</span>,
    <span class="string">"moduleResolution"</span>: <span class="string">"node"</span>,
    <span class="string">"outDir"</span>: <span class="string">"lib"</span>,
    <span class="string">"skipLibCheck"</span>: <span class="keyword">true</span>,
    <span class="string">"sourceMap"</span>: <span class="keyword">true</span>,
    <span class="string">"target"</span>: <span class="string">"esnext"</span>,
    <span class="string">"typeRoots"</span>: [<span class="string">"node_modules/@types"</span>],
  },
  <span class="string">"include"</span>: [
    <span class="string">"src/**/*.ts"</span>,
  ]
}</code></pre>
<p>Set up the compilation as a <code>package.json</code> script with:</p>
<pre><code class="language-json">{
  <span class="string">"scripts"</span>: {
    <span class="string">"compile"</span>: <span class="string">"tsc"</span>,
    <span class="string">"compile-watch"</span>: <span class="string">"tsc --watch"</span>
  }
}</code></pre>
<p>Running <code>jspm run compile</code> (or <code>compile-watch</code>) will now compile the all <code>.ts</code> files in the <code><span class="string">"src"</span></code> folder to the <code><span class="string">"lib"</span></code> folder as ES modules. In addition this compilation workflow will be fully incremental, only doing the work it needs to do.</p>
<p>This can then be combined with a <code><span class="string">"build"</span></code> script to handle optimization or browser mappings. The <code><span class="string">"lib"</span></code> folder can be treated like the <code><span class="string">"src"</span></code> folder from the perspective of all the jspm map and optimization workflows as described in the <a href="/docs/guide">main guide</a>. For example, build a single-file browser script build with <code>jspm build lib/test.js --production -f iife</code>, etc.</p>
</details>

<a name="vuejs" class="anchor"></a><h2>Vue.js</h2>
<p>Vue.js production builds are supported with <code>jspm build --production</code>.</p>
<p>To support <code>.vue</code> files, use a custom build workflow like <a href="#Rollup">Rollup</a> with the <a href="https://github.com/vuejs/rollup-plugin-vue" target="_blank" rel="noopener">Rollup Vue plugin</a>.</p>
<p><em>Precompilation Vue.js workflow pending.</em></p>
<a name="webpack" class="anchor"></a><h2>Webpack</h2>
<p><em>Webpack plugin still needs to be created.</em></p>
<a name="one-weird-trick-to-support-jspm-in-tools" class="anchor"></a><h2>One Weird Trick to Support jspm in Tools</h2>
<p>If you're a tooling author, whenever loading or executing code dynamically in CommonJS, use the pattern:</p>
<pre><code class="language-js">Promise.resolve(require(dynamicModuleExpression))</code></pre>
<p>By immediately wrapping the <code>require</code> statement in <code>Promise.resolve()</code>, and handling the promise properly, jspm will then automatically replace this during CommonJS conversion on install with <code><span class="keyword">import</span>(dynamicModuleExpresion)</code>, thereby providing comprehensive ES module and dependency resolution for dynamic requires, which would usually be a problem as they are not statically analyzable.</p>
<p>This pattern is exactly what allows RollupJS configuration files to full support loading Rollup plugins as ES modules through jspm, and hopefully other tools can follow.</p>
<div class="nextprev"><a class="edit" target="_blank" href="https://github.com/jspm/jspm.org/blob/master/docs/integrations.md" rel="noopener">Edit</a><div class="prev"><a href="/docs/guide">◀&nbsp;Guide</a></div></div></div>


</body></html>